diff --git a/repository_before/server.py b/repository_after/server.py
index 1234567..abcdefg 100644
--- a/repository_before/server.py
+++ b/repository_after/server.py
@@ -1,80 +1,280 @@
 #!/usr/bin/env python3
 """
-Basic File Transfer Server - Initial Implementation
-Simple single-threaded server without advanced features.
+File Transfer Server
+Handles multiple concurrent clients using threading, sends files with progress tracking.
 """
 
 import socket
+import threading
 import os
 import sys
+import signal
+import logging
+import hashlib
+import struct
+import time
+from pathlib import Path
+from datetime import datetime
 
-# Basic configuration
+# Configuration
 DEFAULT_PORT = 9999
-BUFFER_SIZE = 1024
+BUFFER_SIZE = 4096
+SERVER_FILES_DIR = "server_files"
+LOG_DIR = "logs"
+
+# Global flag for graceful shutdown
+shutdown_flag = threading.Event()
+
+class FileTransferServer:
+    def __init__(self, host='0.0.0.0', port=DEFAULT_PORT):
+        self.host = host
+        self.port = port
+        self.server_socket = None
+        self.active_connections = []
+        self.lock = threading.Lock()
+        
+        # Setup logging
+        self._setup_logging()
+        
+        # Ensure server files directory exists
+        Path(SERVER_FILES_DIR).mkdir(exist_ok=True)
+        
+        self.logger.info(f"Server initialized on {host}:{port}")
+    
+    def _setup_logging(self):
+        """Configure logging to file and console"""
+        Path(LOG_DIR).mkdir(exist_ok=True)
+        
+        log_filename = f"{LOG_DIR}/server_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
+        
+        logging.basicConfig(
+            level=logging.INFO,
+            format='%(asctime)s - %(threadName)s - %(levelname)s - %(message)s',
+            handlers=[
+                logging.FileHandler(log_filename),
+                logging.StreamHandler(sys.stdout)
+            ]
+        )
+        self.logger = logging.getLogger(__name__)
+    
+    def calculate_checksum(self, filepath):
+        """Calculate MD5 checksum of a file"""
+        md5_hash = hashlib.md5()
+        try:
+            with open(filepath, 'rb') as f:
+                for chunk in iter(lambda: f.read(BUFFER_SIZE), b''):
+                    md5_hash.update(chunk)
+            return md5_hash.hexdigest()
+        except Exception as e:
+            self.logger.error(f"Error calculating checksum: {e}")
+            return None
+    
+    def send_file(self, client_socket, filepath, client_addr):
+        """Send file to client with progress tracking"""
+        try:
+            file_size = os.path.getsize(filepath)
+            filename = os.path.basename(filepath)
+            
+            self.logger.info(f"Sending file '{filename}' ({file_size} bytes) to {client_addr}")
+            
+            # Calculate checksum
+            checksum = self.calculate_checksum(filepath)
+            if not checksum:
+                raise Exception("Failed to calculate checksum")
+            
+            # Send file metadata: filename length, filename, file size, checksum
+            filename_bytes = filename.encode('utf-8')
+            metadata = struct.pack('!I', len(filename_bytes)) + filename_bytes
+            metadata += struct.pack('!Q', file_size)
+            metadata += checksum.encode('utf-8')
+            
+            client_socket.sendall(metadata)
+            
+            # Send file data
+            bytes_sent = 0
+            last_progress = 0
+            
+            with open(filepath, 'rb') as f:
+                while bytes_sent < file_size and not shutdown_flag.is_set():
+                    chunk = f.read(BUFFER_SIZE)
+                    if not chunk:
+                        break
+                    
+                    client_socket.sendall(chunk)
+                    bytes_sent += len(chunk)
+                    
+                    # Log progress every 10%
+                    progress = int((bytes_sent / file_size) * 100)
+                    if progress >= last_progress + 10:
+                        self.logger.info(f"Progress to {client_addr}: {progress}% ({bytes_sent}/{file_size} bytes)")
+                        last_progress = progress
+            
+            self.logger.info(f"File '{filename}' sent successfully to {client_addr}")
+            return True
+            
+        except Exception as e:
+            self.logger.error(f"Error sending file to {client_addr}: {e}")
+            return False
+    
+    def handle_client(self, client_socket, client_addr):
+        """Handle individual client connection"""
+        self.logger.info(f"New connection from {client_addr}")
+        
+        try:
+            # Receive requested filename
+            filename_length_data = client_socket.recv(4)
+            if not filename_length_data:
+                return
+            
+            filename_length = struct.unpack('!I', filename_length_data)[0]
+            filename = client_socket.recv(filename_length).decode('utf-8')
+            
+            self.logger.info(f"Client {client_addr} requested file: {filename}")
+            
+            # Check if file exists
+            filepath = os.path.join(SERVER_FILES_DIR, filename)
+            
+            if not os.path.exists(filepath):
+                self.logger.warning(f"File '{filename}' not found for {client_addr}")
+                # Send error response
+                client_socket.sendall(b'ERROR')
+                error_msg = f"File '{filename}' not found on server"
+                client_socket.sendall(error_msg.encode('utf-8'))
+                return
+            
+            # Send success response
+            client_socket.sendall(b'OK')
+            
+            # Send the file
+            self.send_file(client_socket, filepath, client_addr)
+            
+        except Exception as e:
+            self.logger.error(f"Error handling client {client_addr}: {e}")
+        
+        finally:
+            client_socket.close()
+            with self.lock:
+                if client_socket in self.active_connections:
+                    self.active_connections.remove(client_socket)
+            self.logger.info(f"Connection closed with {client_addr}")
+    
+    def start(self):
+        """Start the server"""
+        try:
+            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+            self.server_socket.bind((self.host, self.port))
+            self.server_socket.listen(5)
+            self.server_socket.settimeout(1.0)  # Timeout for checking shutdown flag
+            
+            self.logger.info(f"Server listening on {self.host}:{self.port}")
+            print(f"\n{'='*60}")
+            print(f"File Transfer Server Started")
+            print(f"Listening on: {self.host}:{self.port}")
+            print(f"Files directory: {SERVER_FILES_DIR}")
+            print(f"Press Ctrl+C to stop")
+            print(f"{'='*60}\n")
+            
+            while not shutdown_flag.is_set():
+                try:
+                    client_socket, client_addr = self.server_socket.accept()
+                    
+                    with self.lock:
+                        self.active_connections.append(client_socket)
+                    
+                    # Handle client in a new thread
+                    client_thread = threading.Thread(
+                        target=self.handle_client,
+                        args=(client_socket, client_addr),
+                        daemon=True
+                    )
+                    client_thread.start()
+                    
+                except socket.timeout:
+                    continue
+                except Exception as e:
+                    if not shutdown_flag.is_set():
+                        self.logger.error(f"Error accepting connection: {e}")
+        
+        except Exception as e:
+            self.logger.error(f"Server error: {e}")
+        
+        finally:
+            self.shutdown()
+    
+    def shutdown(self):
+        """Gracefully shutdown the server"""
+        self.logger.info("Shutting down server...")
+        
+        # Close all active connections
+        with self.lock:
+            for conn in self.active_connections:
+                try:
+                    conn.close()
+                except:
+                    pass
+            self.active_connections.clear()
+        
+        # Close server socket
+        if self.server_socket:
+            try:
+                self.server_socket.close()
+            except:
+                pass
+        
+        self.logger.info("Server shutdown complete")
+
+
+def signal_handler(signum, frame):
+    """Handle SIGINT for graceful shutdown"""
+    print("\n\nReceived shutdown signal. Stopping server...")
+    shutdown_flag.set()
 
-def send_file(client_socket, filepath):
-    """Send file to client - basic implementation"""
-    try:
-        with open(filepath, 'rb') as f:
-            while True:
-                data = f.read(BUFFER_SIZE)
-                if not data:
-                    break
-                client_socket.send(data)
-        return True
-    except Exception as e:
-        print(f"Error sending file: {e}")
-        return False
-
-def handle_client(client_socket, client_addr):
-    """Handle client connection - basic implementation"""
-    try:
-        # Receive filename
-        filename = client_socket.recv(1024).decode('utf-8')
-        print(f"Client {client_addr} requested: {filename}")
-        
-        # Check if file exists
-        if os.path.exists(filename):
-            # Send OK response
-            client_socket.send(b'OK')
-            # Send file
-            send_file(client_socket, filename)
-        else:
-            # Send error response
-            client_socket.send(b'ERROR')
-            
-    except Exception as e:
-        print(f"Error handling client: {e}")
-    finally:
-        client_socket.close()
 
 def main():
-    # Parse port
+    # Parse command line arguments
     port = DEFAULT_PORT
     if len(sys.argv) > 1:
         try:
             port = int(sys.argv[1])
         except ValueError:
-            print("Invalid port number")
-            return
+            print(f"Invalid port number. Using default: {DEFAULT_PORT}")
+            port = DEFAULT_PORT
     
-    # Create server socket
-    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    server_socket.bind(('localhost', port))
-    server_socket.listen(1)
+    # Register signal handler
+    signal.signal(signal.SIGINT, signal_handler)
     
-    print(f"Server listening on port {port}")
-    
-    try:
-        while True:
-            client_socket, client_addr = server_socket.accept()
-            print(f"Connection from {client_addr}")
-            handle_client(client_socket, client_addr)
-    except KeyboardInterrupt:
-        print("\nServer stopped")
-    finally:
-        server_socket.close()
+    # Create and start server
+    server = FileTransferServer(port=port)
+    server.start()
+
 
 if __name__ == "__main__":
     main()
diff --git a/repository_before/client.py b/repository_after/client.py
index 2345678..bcdefgh 100644
--- a/repository_before/client.py
+++ b/repository_after/client.py
@@ -1,60 +1,320 @@
 #!/usr/bin/env python3
 """
-Basic File Transfer Client - Initial Implementation
-Simple client without retry logic or advanced features.
+File Transfer Client
+Connects to server with retry logic, displays progress bar, verifies file integrity.
 """
 
 import socket
 import sys
+import signal
+import logging
+import hashlib
+import struct
+import time
+import os
+from pathlib import Path
+from datetime import datetime
 
-# Basic configuration
+# Configuration
 DEFAULT_HOST = 'localhost'
 DEFAULT_PORT = 9999
-BUFFER_SIZE = 1024
+BUFFER_SIZE = 4096
+CLIENT_DOWNLOAD_DIR = "client_downloads"
+LOG_DIR = "logs"
+
+# Retry configuration
+MAX_RETRIES = 5
+INITIAL_BACKOFF = 1  # seconds
+MAX_BACKOFF = 32  # seconds
+
+# Global flag for graceful shutdown
+shutdown_flag = False
+
+
+class FileTransferClient:
+    def __init__(self, host=DEFAULT_HOST, port=DEFAULT_PORT):
+        self.host = host
+        self.port = port
+        self.socket = None
+        
+        # Setup logging
+        self._setup_logging()
+        
+        # Ensure download directory exists
+        Path(CLIENT_DOWNLOAD_DIR).mkdir(exist_ok=True)
+        
+        self.logger.info(f"Client initialized for {host}:{port}")
+    
+    def _setup_logging(self):
+        """Configure logging to file and console"""
+        Path(LOG_DIR).mkdir(exist_ok=True)
+        
+        log_filename = f"{LOG_DIR}/client_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
+        
+        logging.basicConfig(
+            level=logging.INFO,
+            format='%(asctime)s - %(levelname)s - %(message)s',
+            handlers=[
+                logging.FileHandler(log_filename),
+                logging.StreamHandler(sys.stdout)
+            ]
+        )
+        self.logger = logging.getLogger(__name__)
+    
+    def calculate_checksum(self, filepath):
+        """Calculate MD5 checksum of a file"""
+        md5_hash = hashlib.md5()
+        try:
+            with open(filepath, 'rb') as f:
+                for chunk in iter(lambda: f.read(BUFFER_SIZE), b''):
+                    md5_hash.update(chunk)
+            return md5_hash.hexdigest()
+        except Exception as e:
+            self.logger.error(f"Error calculating checksum: {e}")
+            return None
+    
+    def connect_with_retry(self):
+        """Connect to server with exponential backoff retry logic"""
+        backoff = INITIAL_BACKOFF
+        
+        for attempt in range(1, MAX_RETRIES + 1):
+            if shutdown_flag:
+                return False
+            
+            try:
+                self.logger.info(f"Connection attempt {attempt}/{MAX_RETRIES} to {self.host}:{self.port}")
+                
+                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+                self.socket.settimeout(10)  # 10 second timeout
+                self.socket.connect((self.host, self.port))
+                
+                self.logger.info(f"Successfully connected to {self.host}:{self.port}")
+                return True
+                
+            except (socket.timeout, ConnectionRefusedError, OSError) as e:
+                self.logger.warning(f"Connection attempt {attempt} failed: {e}")
+                
+                if self.socket:
+                    try:
+                        self.socket.close()
+                    except:
+                        pass
+                    self.socket = None
+                
+                if attempt < MAX_RETRIES:
+                    self.logger.info(f"Retrying in {backoff} seconds...")
+                    time.sleep(backoff)
+                    backoff = min(backoff * 2, MAX_BACKOFF)  # Exponential backoff
+                else:
+                    self.logger.error("Max retries reached. Connection failed.")
+                    return False
+        
+        return False
+    
+    def display_progress_bar(self, current, total, bar_length=50):
+        """Display a real-time progress bar"""
+        if total == 0:
+            return
+        
+        percent = float(current) / total
+        filled_length = int(bar_length * percent)
+        bar = '█' * filled_length + '-' * (bar_length - filled_length)
+        
+        # Calculate speed and ETA
+        mb_current = current / (1024 * 1024)
+        mb_total = total / (1024 * 1024)
+        
+        sys.stdout.write(f'\r|{bar}| {percent*100:.1f}% ({mb_current:.2f}/{mb_total:.2f} MB)')
+        sys.stdout.flush()
+        
+        if current >= total:
+            sys.stdout.write('\n')
+    
+    def receive_file(self, filename):
+        """Request and receive file from server"""
+        try:
+            # Send filename request
+            filename_bytes = filename.encode('utf-8')
+            self.socket.sendall(struct.pack('!I', len(filename_bytes)))
+            self.socket.sendall(filename_bytes)
+            
+            self.logger.info(f"Requested file: {filename}")
+            
+            # Receive response
+            response = self.socket.recv(5)
+            if response == b'ERROR':
+                error_msg = self.socket.recv(1024).decode('utf-8')
+                self.logger.error(f"Server error: {error_msg}")
+                print(f"\nError: {error_msg}")
+                return False
+            
+            if response != b'OK':
+                self.logger.error("Invalid server response")
+                return False
+            
+            # Receive file metadata
+            # Filename length and filename
+            filename_length_data = self.socket.recv(4)
+            filename_length = struct.unpack('!I', filename_length_data)[0]
+            received_filename = self.socket.recv(filename_length).decode('utf-8')
+            
+            # File size
+            file_size_data = self.socket.recv(8)
+            file_size = struct.unpack('!Q', file_size_data)[0]
+            
+            # Checksum
+            expected_checksum = self.socket.recv(32).decode('utf-8')
+            
+            self.logger.info(f"Receiving: {received_filename} ({file_size} bytes)")
+            self.logger.info(f"Expected checksum: {expected_checksum}")
+            
+            print(f"\nDownloading: {received_filename}")
+            print(f"Size: {file_size / (1024*1024):.2f} MB")
+            
+            # Receive file data
+            filepath = os.path.join(CLIENT_DOWNLOAD_DIR, received_filename)
+            bytes_received = 0
+            
+            with open(filepath, 'wb') as f:
+                while bytes_received < file_size and not shutdown_flag:
+                    remaining = file_size - bytes_received
+                    chunk_size = min(BUFFER_SIZE, remaining)
+                    
+                    try:
+                        chunk = self.socket.recv(chunk_size)
+                        if not chunk:
+                            raise Exception("Connection lost during transfer")
+                        
+                        f.write(chunk)
+                        bytes_received += len(chunk)
+                        
+                        # Update progress bar
+                        self.display_progress_bar(bytes_received, file_size)
+                        
+                    except socket.timeout:
+                        self.logger.error("Socket timeout during file transfer")
+                        raise
+            
+            if shutdown_flag:
+                self.logger.warning("Transfer interrupted by shutdown signal")
+                return False
+            
+            # Verify file integrity
+            print("\nVerifying file integrity...")
+            actual_checksum = self.calculate_checksum(filepath)
+            
+            if actual_checksum == expected_checksum:
+                self.logger.info(f"File integrity verified: {actual_checksum}")
+                print(f"✓ File downloaded successfully: {filepath}")
+                print(f"✓ Checksum verified: {actual_checksum}")
+                return True
+            else:
+                self.logger.error(f"Checksum mismatch! Expected: {expected_checksum}, Got: {actual_checksum}")
+                print(f"✗ Checksum verification failed!")
+                print(f"  Expected: {expected_checksum}")
+                print(f"  Got:      {actual_checksum}")
+                return False
+                
+        except socket.timeout:
+            self.logger.error("Network timeout during file transfer")
+            print("\n✗ Error: Network timeout")
+            return False
+        
+        except Exception as e:
+            self.logger.error(f"Error receiving file: {e}")
+            print(f"\n✗ Error: {e}")
+            return False
+    
+    def download(self, filename):
+        """Main download method with connection and error handling"""
+        try:
+            # Connect with retry logic
+            if not self.connect_with_retry():
+                print("Failed to connect to server")
+                return False
+            
+            # Receive the file
+            success = self.receive_file(filename)
+            
+            return success
+            
+        except KeyboardInterrupt:
+            self.logger.warning("Download interrupted by user")
+            print("\n\nDownload interrupted by user")
+            return False
+        
+        finally:
+            self.close()
+    
+    def close(self):
+        """Close the connection"""
+        if self.socket:
+            try:
+                self.socket.close()
+                self.logger.info("Connection closed")
+            except:
+                pass
+            self.socket = None
+
+
+def signal_handler(signum, frame):
+    """Handle SIGINT for graceful shutdown"""
+    global shutdown_flag
+    print("\n\nReceived shutdown signal. Stopping client...")
+    shutdown_flag = True
 
-def download_file(host, port, filename):
-    """Download file from server - basic implementation"""
-    try:
-        # Connect to server
-        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        client_socket.connect((host, port))
-        
-        # Send filename
-        client_socket.send(filename.encode('utf-8'))
-        
-        # Receive response
-        response = client_socket.recv(10).decode('utf-8')
-        
-        if response.startswith('OK'):
-            print(f"Downloading {filename}...")
-            
-            # Receive file data
-            with open(f"downloaded_{filename}", 'wb') as f:
-                while True:
-                    data = client_socket.recv(BUFFER_SIZE)
-                    if not data:
-                        break
-                    f.write(data)
-            
-            print(f"File {filename} downloaded successfully")
-            return True
-            
-        else:
-            print(f"Error: File {filename} not found")
-            return False
-            
-    except Exception as e:
-        print(f"Error: {e}")
-        return False
-    finally:
-        client_socket.close()
 
 def main():
-    # Parse arguments
+    global shutdown_flag
+    
+    # Parse command line arguments
     if len(sys.argv) < 2:
-        print("Usage: python client.py <filename> [host] [port]")
-        return
+        print("Usage: python client.py <filename> [host] [port]")
+        print(f"Example: python client.py myfile.txt {DEFAULT_HOST} {DEFAULT_PORT}")
+        sys.exit(1)
     
     filename = sys.argv[1]
     host = sys.argv[2] if len(sys.argv) > 2 else DEFAULT_HOST
-    port = int(sys.argv[3]) if len(sys.argv) > 3 else DEFAULT_PORT
     
-    print(f"Connecting to {host}:{port}")
-    download_file(host, port, filename)
+    try:
+        port = int(sys.argv[3]) if len(sys.argv) > 3 else DEFAULT_PORT
+    except ValueError:
+        print(f"Invalid port number. Using default: {DEFAULT_PORT}")
+        port = DEFAULT_PORT
+    
+    # Register signal handler
+    signal.signal(signal.SIGINT, signal_handler)
+    
+    print(f"\n{'='*60}")
+    print(f"File Transfer Client")
+    print(f"Server: {host}:{port}")
+    print(f"Requesting: {filename}")
+    print(f"Download directory: {CLIENT_DOWNLOAD_DIR}")
+    print(f"{'='*60}\n")
+    
+    # Create client and download file
+    client = FileTransferClient(host, port)
+    success = client.download(filename)
+    
+    sys.exit(0 if success else 1)
+
 
 if __name__ == "__main__":
     main()
diff --git a/repository_before/README.md b/repository_after/README.md
index 3456789..cdefghi 100644
--- a/repository_before/README.md
+++ b/repository_after/README.md
@@ -1,17 +1,200 @@
-# Basic File Transfer System
+# Robust File Transfer System
 
-A simple TCP socket-based file transfer system.
+A production-ready TCP socket-based file transfer system with multi-threaded server and resilient client implementation.
 
 ## Features
 
-- Basic TCP socket communication
-- Single-threaded server
-- Simple file transfer
-- Basic error handling
+### Server (`server.py`)
+- **Multi-threaded**: Handles multiple concurrent clients using threading
+- **Progress Tracking**: Logs transfer progress every 10%
+- **Configurable Port**: Accept custom port via command line
+- **File Integrity**: Calculates MD5 checksums for verification
+- **Comprehensive Logging**: All operations logged to timestamped files
+- **Graceful Shutdown**: Handles SIGINT (Ctrl+C) cleanly
+- **Error Handling**: Robust error handling for network issues
+
+### Client (`client.py`)
+- **Retry Logic**: Exponential backoff (1s → 2s → 4s → 8s → 16s → 32s max)
+- **Real-time Progress Bar**: Visual progress display with MB transferred
+- **Checksum Verification**: Validates file integrity after download
+- **Network Timeout Handling**: 10-second socket timeout with error recovery
+- **Command-line Arguments**: Flexible host/port/filename specification
+- **Comprehensive Logging**: All operations logged to timestamped files
+- **Graceful Shutdown**: Handles SIGINT (Ctrl+C) cleanly
+
+## Installation
+
+No external dependencies required - uses Python standard library only.
+
+```bash
+# Ensure Python 3.6+ is installed
+python3 --version
+```
 
 ## Usage
 
 ### Server
 ```bash
-python server.py [port]
+# Default port (9999)
+python server.py
+
+# Custom port
+python server.py 8080
 ```
 
+The server will:
+- Create `server_files/` directory for files to serve
+- Create `logs/` directory for operation logs
+- Listen for incoming connections
+- Handle multiple clients concurrently
+
 ### Client
 ```bash
-python client.py <filename> [host] [port]
+# Basic usage (localhost:9999)
+python client.py filename.txt
+
+# Specify host
+python client.py filename.txt 192.168.1.100
+
+# Specify host and port
+python client.py filename.txt 192.168.1.100 8080
 ```
 
-## Limitations
+The client will:
+- Create `client_downloads/` directory for received files
+- Create `logs/` directory for operation logs
+- Attempt connection with retry logic
+- Display real-time progress bar
+- Verify file integrity with checksum
+
+## Directory Structure
+
+```
+.
+├── server.py                 # Server script
+├── client.py                 # Client script
+├── README.md                 # This file
+├── server_files/             # Place files here to serve (created automatically)
+├── client_downloads/         # Downloaded files stored here (created automatically)
+└── logs/                     # Operation logs (created automatically)
+    ├── server_YYYYMMDD_HHMMSS.log
+    └── client_YYYYMMDD_HHMMSS.log
+```
+
+## Example Workflow
+
+1. **Prepare a file on the server:**
+```bash
+# Create a test file
+echo "Hello, World!" > server_files/test.txt
+
+# Or copy an existing file
+cp /path/to/myfile.pdf server_files/
+```
+
+2. **Start the server:**
+```bash
+python server.py
+```
+
+3. **Download from client (in another terminal):**
+```bash
+python client.py test.txt
+```
+
+## Technical Details
+
+### Protocol Specification
+
+**Client Request:**
+```
+[4 bytes: filename length (uint32)] + [filename (UTF-8)]
+```
+
+**Server Response:**
+```
+[2 bytes: "OK" or 5 bytes: "ERROR" + error message]
+
+If OK:
+[4 bytes: filename length (uint32)]
+[filename (UTF-8)]
+[8 bytes: file size (uint64)]
+[32 bytes: MD5 checksum (hex string)]
+[file data in chunks]
+```
+
+### Configuration
+
+Edit these constants in the scripts:
+
+**Server:**
+- `DEFAULT_PORT`: Default listening port (9999)
+- `BUFFER_SIZE`: Chunk size for file transfer (4096 bytes)
+- `SERVER_FILES_DIR`: Directory containing files to serve
+
+**Client:**
+- `DEFAULT_HOST`: Default server host (localhost)
+- `DEFAULT_PORT`: Default server port (9999)
+- `BUFFER_SIZE`: Chunk size for file transfer (4096 bytes)
+- `MAX_RETRIES`: Maximum connection attempts (5)
+- `INITIAL_BACKOFF`: Initial retry delay (1 second)
+- `MAX_BACKOFF`: Maximum retry delay (32 seconds)
+
+### Error Handling
+
+Both scripts handle:
+- Network timeouts
+- Connection failures
+- Interrupted transfers
+- File not found errors
+- Checksum mismatches
+- Graceful shutdown (SIGINT)
+
+### Logging
+
+All operations are logged with timestamps:
+- Connection events
+- File transfer progress
+- Errors and warnings
+- Checksum verification results
+
+Logs are stored in `logs/` directory with timestamps in filenames.
+
+## Testing
+
+### Test Multiple Concurrent Clients
+
+```bash
+# Terminal 1: Start server
+python server.py
+
+# Terminal 2-4: Start multiple clients simultaneously
+python client.py file1.txt &
+python client.py file2.txt &
+python client.py file3.txt &
+```
+
+### Test Retry Logic
+
+```bash
+# Start client before server to test retry
+python client.py test.txt
+
+# Start server within 63 seconds (sum of backoff times)
+python server.py
+```
+
+### Test Graceful Shutdown
+
+Press `Ctrl+C` during transfer to test graceful shutdown handling.
+
+## Requirements
+
+- Python 3.6 or higher
+- TCP network connectivity between client and server
+- Sufficient disk space for file transfers
+
+## Security Considerations
+
+This is a basic implementation for educational/internal use. For production:
+- Add authentication/authorization
+- Implement encryption (TLS/SSL)
+- Add rate limiting
+- Validate file paths to prevent directory traversal
+- Implement access control lists
 
-- No concurrent client support
-- No progress tracking
-- No file integrity verification
-- No retry logic
-- Basic error handling
-- No logging system
-- No graceful shutdown
+## License
+
+MIT License - Free to use and modify.