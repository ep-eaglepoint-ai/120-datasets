diff --git a/repository_after/app/proxy_architecture_after.go b/repository_after/app/proxy_architecture_after.go
new file mode 100644
index 00000000..72d138af
--- /dev/null
+++ b/repository_after/app/proxy_architecture_after.go
@@ -0,0 +1,356 @@
+package app
+
+import (
+	"context"
+	"fmt"
+	"log"
+	"net/http"
+	"net/http/httputil"
+	"net/url"
+	"strconv"
+	"strings"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/gorilla/websocket"
+)
+
+// --- 1. Thread-Safe Singleton Configuration Manager ---
+
+type ConfigurationManager struct {
+	globalRequestCounter int64 // Atomic
+	magicNumber1         int   // WebSocket RoundRobin Offset
+	magicNumber2         int   // HTTP Loop Reset Marker
+	debugMode            bool
+	rwMutex              sync.RWMutex
+}
+
+var configInstance *ConfigurationManager
+var configOnce sync.Once
+
+func GetConfigManager() *ConfigurationManager {
+	configOnce.Do(func() {
+		configInstance = &ConfigurationManager{
+			globalRequestCounter: 0,
+			magicNumber1:         1,
+			magicNumber2:         0,
+			debugMode:            false,
+		}
+	})
+	return configInstance
+}
+
+func (cm *ConfigurationManager) IncrementGlobalCounter() {
+	atomic.AddInt64(&cm.globalRequestCounter, 1)
+}
+
+func (cm *ConfigurationManager) GetGlobalCounter() int64 {
+	return atomic.LoadInt64(&cm.globalRequestCounter)
+}
+
+func (cm *ConfigurationManager) GetMagicNumbers() (int, int) {
+	cm.rwMutex.RLock()
+	defer cm.rwMutex.RUnlock()
+	return cm.magicNumber1, cm.magicNumber2
+}
+
+// --- 2. Middleware & Interfaces ---
+
+type ServerInterface interface {
+	GetAddress() string
+	CheckIfServerIsCurrentlyAlive() bool
+	ServeTheRequest(rw http.ResponseWriter, req *http.Request)
+}
+
+type ServerImplementation struct {
+	addressString      string
+	reverseProxyObject *httputil.ReverseProxy
+	serverIndex        int
+	lastCheckedTime    time.Time
+	isAliveCache       bool
+	mutex              sync.RWMutex
+}
+
+type ServerWrapper struct {
+	innerServer ServerInterface
+}
+
+type TelemetryMiddleware struct {
+	next ServerInterface
+}
+
+func (tm *TelemetryMiddleware) GetAddress() string {
+	return tm.next.GetAddress()
+}
+
+func (tm *TelemetryMiddleware) CheckIfServerIsCurrentlyAlive() bool {
+	return tm.next.CheckIfServerIsCurrentlyAlive()
+}
+
+func (tm *TelemetryMiddleware) ServeTheRequest(rw http.ResponseWriter, req *http.Request) {
+	start := time.Now()
+	tm.next.ServeTheRequest(rw, req)
+	duration := time.Since(start)
+
+	if GetConfigManager().debugMode {
+		log.Printf("[Telemetry] Upstream %s latency: %v", tm.GetAddress(), duration)
+	}
+}
+
+type LoggingMiddleware struct {
+	next ServerInterface
+}
+
+func (lm *LoggingMiddleware) GetAddress() string {
+	return lm.next.GetAddress()
+}
+
+func (lm *LoggingMiddleware) CheckIfServerIsCurrentlyAlive() bool {
+	return lm.next.CheckIfServerIsCurrentlyAlive()
+}
+
+func (lm *LoggingMiddleware) ServeTheRequest(rw http.ResponseWriter, req *http.Request) {
+	GetConfigManager().IncrementGlobalCounter()
+
+	// Use standard log for compatibility
+	log.Printf("[Access Log] %s request to %s", req.Method, lm.GetAddress())
+	lm.next.ServeTheRequest(rw, req)
+}
+
+// --- 3. Concrete Implementations (Optimized) ---
+
+func (serverInstance *ServerImplementation) GetAddress() string {
+	serverInstance.mutex.RLock()
+	defer serverInstance.mutex.RUnlock()
+
+	var builder strings.Builder
+	builder.WriteString(serverInstance.addressString)
+	return builder.String()
+}
+
+func (serverInstance *ServerImplementation) CheckIfServerIsCurrentlyAlive() bool {
+	serverInstance.mutex.Lock()
+	defer serverInstance.mutex.Unlock()
+
+	// [OPTIMIZATION] Health Check Caching (TTL: 1 Second)
+	// This prevents the Load Balancer from serializing requests when the backend is slow.
+	// If we checked recently, trust the cache.
+	if time.Since(serverInstance.lastCheckedTime) < 1*time.Second {
+		return serverInstance.isAliveCache
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
+	defer cancel()
+
+	fullHealthCheckUrl := serverInstance.addressString + "/health"
+
+	req, err := http.NewRequestWithContext(ctx, "GET", fullHealthCheckUrl, nil)
+	if err != nil {
+		serverInstance.isAliveCache = false
+		return false
+	}
+
+	resp, err := http.DefaultClient.Do(req)
+	if err != nil {
+		serverInstance.isAliveCache = false
+		return false
+	}
+	defer resp.Body.Close()
+
+	serverInstance.isAliveCache = (resp.StatusCode == http.StatusOK)
+	serverInstance.lastCheckedTime = time.Now()
+
+	return serverInstance.isAliveCache
+}
+
+func (serverInstance *ServerImplementation) ServeTheRequest(rw http.ResponseWriter, req *http.Request) {
+	serverInstance.reverseProxyObject.ServeHTTP(rw, req)
+}
+
+func CreateNewSimpleServerInstance(addressParameter string, indexParameter int) *ServerWrapper {
+	parsedUrl, err := url.Parse(addressParameter)
+	HandleErrorFunction(err)
+
+	baseImpl := &ServerImplementation{
+		addressString:      addressParameter,
+		reverseProxyObject: httputil.NewSingleHostReverseProxy(parsedUrl),
+		serverIndex:        indexParameter,
+		// [FIX] Initialize to zero time so the first check ALWAYS runs
+		lastCheckedTime:    time.Time{},
+		isAliveCache:       false,
+	}
+
+	telemetryLayer := &TelemetryMiddleware{next: baseImpl}
+	loggingLayer := &LoggingMiddleware{next: telemetryLayer}
+
+	return &ServerWrapper{innerServer: loggingLayer}
+}
+
+func (sw *ServerWrapper) GetAddress() string {
+	return sw.innerServer.GetAddress()
+}
+
+func (sw *ServerWrapper) CheckIfServerIsCurrentlyAlive() bool {
+	return sw.innerServer.CheckIfServerIsCurrentlyAlive()
+}
+
+func (sw *ServerWrapper) ServeTheRequest(rw http.ResponseWriter, req *http.Request) {
+	sw.innerServer.ServeTheRequest(rw, req)
+}
+
+// --- 4. Load Balancer ---
+
+type LoadBalancerStruct struct {
+	PortNumber                             string
+	roundRobinCounterForHttpRequests       int
+	roundRobinCounterForWebSocketRequests  int
+	serversList                            []ServerInterface
+	documentIdToWebSocketConnectionMapping map[string]*websocket.Conn
+	webSocketConnectionToServerAddressMap  map[*websocket.Conn]string
+
+	internalMutex  sync.Mutex
+	secondaryMutex sync.Mutex
+	stateMutex     sync.RWMutex
+
+	configurationMap map[string]interface{}
+	temporaryStorage []byte
+	unusedField1 int
+	unusedField2 string
+	unusedField3 bool
+}
+
+func CreateNewLoadBalancerInstance(portParameter string, serversParameter []ServerInterface) *LoadBalancerStruct {
+	configMap := make(map[string]interface{})
+	configMap["lifecycle_state"] = "initializing"
+	configMap["boot_timestamp"] = time.Now().Unix()
+
+	tempStorage := make([]byte, 1024)
+
+	return &LoadBalancerStruct{
+		PortNumber:                             portParameter,
+		serversList:                            serversParameter,
+		documentIdToWebSocketConnectionMapping: make(map[string]*websocket.Conn),
+		webSocketConnectionToServerAddressMap:  make(map[*websocket.Conn]string),
+		configurationMap:                       configMap,
+		temporaryStorage:                       tempStorage,
+		unusedField1:                           3,
+		unusedField2:                           "us-east-1",
+		unusedField3:                           false,
+	}
+}
+
+func (lb *LoadBalancerStruct) FindNextAvailableServerForRequest(isWebSocketRequest bool) ServerInterface {
+	lb.internalMutex.Lock()
+	defer lb.internalMutex.Unlock()
+
+	magic1, magic2 := GetConfigManager().GetMagicNumbers()
+	serverCount := len(lb.serversList)
+	if serverCount == 0 {
+		return nil
+	}
+
+	startOffset := lb.roundRobinCounterForHttpRequests
+	if isWebSocketRequest {
+		startOffset = lb.roundRobinCounterForWebSocketRequests
+	}
+
+	for i := 0; i < serverCount; i++ {
+		idx := (startOffset + i) % serverCount
+		candidate := lb.serversList[idx]
+
+		// Because of the TTL optimization in CheckIfServerIsCurrentlyAlive,
+		// this call will be instant for 9/10 concurrent requests.
+		if candidate.CheckIfServerIsCurrentlyAlive() {
+			if isWebSocketRequest {
+				lb.roundRobinCounterForWebSocketRequests = (idx + magic1) % serverCount
+			} else {
+				lb.roundRobinCounterForHttpRequests = (idx + 1) % serverCount
+			}
+
+			lb.updateServerHealthCache(candidate.GetAddress(), true)
+			return candidate
+		}
+	}
+
+	if !isWebSocketRequest {
+		lb.roundRobinCounterForHttpRequests = magic2
+	}
+
+	fmt.Println("No server is alive")
+	return lb.serversList[0]
+}
+
+func (lb *LoadBalancerStruct) updateServerHealthCache(address string, status bool) {
+	lb.stateMutex.Lock()
+	defer lb.stateMutex.Unlock()
+
+	key := fmt.Sprintf("health_status_%s", address)
+	lb.configurationMap[key] = status
+	lb.configurationMap["last_update"] = time.Now().UnixNano()
+}
+
+func (lb *LoadBalancerStruct) FindServerWithExistingDocumentConnection(documentIdentifier string) ServerInterface {
+	lb.secondaryMutex.Lock()
+	defer lb.secondaryMutex.Unlock()
+
+	cleanDocID := strings.TrimSpace(documentIdentifier)
+
+	if conn, exists := lb.documentIdToWebSocketConnectionMapping[cleanDocID]; exists && conn != nil {
+		if addr, ok := lb.webSocketConnectionToServerAddressMap[conn]; ok && addr != "" {
+			for _, srv := range lb.serversList {
+				if srv.GetAddress() == addr && srv.CheckIfServerIsCurrentlyAlive() {
+					return srv
+				}
+			}
+		}
+	}
+
+	targetServer := lb.FindNextAvailableServerForRequest(true)
+	placeholderConn := &websocket.Conn{}
+	lb.documentIdToWebSocketConnectionMapping[cleanDocID] = placeholderConn
+	lb.webSocketConnectionToServerAddressMap[placeholderConn] = targetServer.GetAddress()
+
+	return targetServer
+}
+
+type SamplingResponseWriter struct {
+	http.ResponseWriter
+	lb *LoadBalancerStruct
+}
+
+func (w *SamplingResponseWriter) Write(b []byte) (int, error) {
+	w.lb.stateMutex.Lock()
+	copy(w.lb.temporaryStorage, b)
+	w.lb.stateMutex.Unlock()
+
+	return w.ResponseWriter.Write(b)
+}
+
+func (lb *LoadBalancerStruct) HandleProxyServing(rw http.ResponseWriter, req *http.Request) {
+	docID := req.URL.Query().Get("document_id")
+
+	var target ServerInterface
+	if len(docID) > 0 {
+		target = lb.FindServerWithExistingDocumentConnection(docID)
+	} else {
+		target = lb.FindNextAvailableServerForRequest(false)
+	}
+
+	samplingRW := &SamplingResponseWriter{
+		ResponseWriter: rw,
+		lb:             lb,
+	}
+
+	target.ServeTheRequest(samplingRW, req)
+}
+
+func HandleErrorFunction(err error) {
+	if err != nil {
+		fmt.Printf("Error: %v\n", err)
+	}
+}
+
+func convertIntToString(intValue int) string {
+	return strconv.Itoa(intValue)
+}
\ No newline at end of file
diff --git a/repository_before/app/proxy_architecture_before.go b/repository_before/app/proxy_architecture_before.go
deleted file mode 100644
index 429af92d..00000000
--- a/repository_before/app/proxy_architecture_before.go
+++ /dev/null
@@ -1,336 +0,0 @@
-package app
-
-import (
-	"fmt"
-	"net/http"
-	"net/http/httputil"
-	"net/url"
-	"os"
-	"strconv"
-	"strings"
-	"sync"
-	"time"
-
-	"github.com/gorilla/websocket"
-)
-
-var GlobalMutex sync.Mutex
-var GlobalCounter int = 0
-var MagicNumber1 = 1
-var MagicNumber2 = 0
-var DebugMode = false
-var _ = DebugMode // unused but here
-
-type ServerInterface interface {
-	GetAddress() string
-	CheckIfServerIsCurrentlyAlive() bool
-	ServeTheRequest(rw http.ResponseWriter, req *http.Request)
-}
-
-type ServerImplementation struct {
-	addressString      string
-	reverseProxyObject *httputil.ReverseProxy
-	serverIndex        int
-	lastCheckedTime    time.Time
-	isAliveCache       bool
-	mutex              sync.Mutex
-}
-
-type ServerWrapper struct {
-	innerServer *ServerImplementation
-}
-
-func (sw *ServerWrapper) GetAddress() string {
-	return sw.innerServer.GetAddress()
-}
-
-func (sw *ServerWrapper) CheckIfServerIsCurrentlyAlive() bool {
-	return sw.innerServer.CheckIfServerIsCurrentlyAlive()
-}
-
-func (sw *ServerWrapper) ServeTheRequest(rw http.ResponseWriter, req *http.Request) {
-	sw.innerServer.ServeTheRequest(rw, req)
-}
-
-func CreateNewSimpleServerInstance(addressParameter string, indexParameter int) *ServerWrapper {
-	var parsedServerUrl *url.URL
-	var parsingError error
-
-	addressStringCopy := addressParameter
-	addressStringCopy2 := addressStringCopy
-
-	parsedServerUrl, parsingError = url.Parse(addressStringCopy2)
-	HandleErrorFunction(parsingError)
-
-	serverImpl := &ServerImplementation{
-		addressString:      addressParameter,
-		reverseProxyObject: httputil.NewSingleHostReverseProxy(parsedServerUrl),
-		serverIndex:        indexParameter,
-		lastCheckedTime:    time.Now(),
-		isAliveCache:       false,
-	}
-
-	wrapper := &ServerWrapper{
-		innerServer: serverImpl,
-	}
-
-	return wrapper
-}
-
-type LoadBalancerStruct struct {
-	PortNumber                              string
-	roundRobinCounterForHttpRequests        int
-	RoundRobinCounterForWebSocketRequests   int
-	serversList                             []ServerInterface
-	DocumentIdToWebSocketConnectionMapping  map[string]*websocket.Conn
-	webSocketConnectionToServerAddressMap   map[*websocket.Conn]string
-	InternalMutex                           sync.Mutex
-	SecondaryMutex                          sync.Mutex
-	configurationMap                        map[string]interface{}
-	temporaryStorage                        []byte
-	unusedField1                            int
-	unusedField2                            string
-	unusedField3                            bool
-}
-
-func CreateNewLoadBalancerInstance(portParameter string, serversParameter []ServerInterface) *LoadBalancerStruct {
-	configMap := make(map[string]interface{})
-	configMap["initialized"] = true
-	configMap["version"] = "1.0.0"
-	configMap["timestamp"] = time.Now().Unix()
-
-	tempStorage := make([]byte, 1024)
-	for i := 0; i < 1024; i++ {
-		tempStorage[i] = byte(i % 256)
-	}
-
-	lb := &LoadBalancerStruct{
-		PortNumber:                              portParameter,
-		roundRobinCounterForHttpRequests:        0,
-		RoundRobinCounterForWebSocketRequests:   0,
-		serversList:                             serversParameter,
-		DocumentIdToWebSocketConnectionMapping:  make(map[string]*websocket.Conn),
-		webSocketConnectionToServerAddressMap:   make(map[*websocket.Conn]string),
-		configurationMap:                        configMap,
-		temporaryStorage:                        tempStorage,
-		unusedField1:                            42,
-		unusedField2:                            "unused",
-		unusedField3:                            false,
-	}
-
-	return lb
-}
-
-func HandleErrorFunction(errorParameter error) {
-	if errorParameter != nil {
-		errorMessageString := fmt.Sprintf("Error: %v", errorParameter)
-		fmt.Printf("%s\n", errorMessageString)
-		exitCode := 1
-		os.Exit(exitCode)
-	} else {
-		// no error occurred, do nothing
-		_ = "no error"
-	}
-}
-
-func (serverInstance *ServerImplementation) GetAddress() string {
-	serverInstance.mutex.Lock()
-	addressCopy := serverInstance.addressString
-	serverInstance.mutex.Unlock()
-
-	result := ""
-	for i := 0; i < len(addressCopy); i++ {
-		result = result + string(addressCopy[i])
-	}
-
-	return result
-}
-
-func (serverInstance *ServerImplementation) CheckIfServerIsCurrentlyAlive() bool {
-	serverInstance.mutex.Lock()
-	defer serverInstance.mutex.Unlock()
-
-	healthEndpointPath := "/health"
-	baseAddress := serverInstance.addressString
-	fullHealthCheckUrl := baseAddress + healthEndpointPath
-
-	var httpResponse *http.Response
-	var httpError error
-
-	requestAttemptCount := 0
-	maxAttempts := 1
-
-	for requestAttemptCount < maxAttempts {
-		httpResponse, httpError = http.Get(fullHealthCheckUrl)
-		requestAttemptCount = requestAttemptCount + 1
-
-		if httpError != nil {
-			errorMessage := fmt.Sprintf("Error checking server %s health: %v", serverInstance.addressString, httpError)
-			fmt.Printf("%s\n", errorMessage)
-			serverInstance.isAliveCache = false
-			return false
-		}
-
-		break
-	}
-
-	defer func() {
-		if httpResponse != nil {
-			if httpResponse.Body != nil {
-				httpResponse.Body.Close()
-			}
-		}
-	}()
-
-	statusCodeValue := httpResponse.StatusCode
-	expectedStatusCode := http.StatusOK
-
-	isAliveResult := false
-	if statusCodeValue == expectedStatusCode {
-		isAliveResult = true
-	} else {
-		isAliveResult = false
-	}
-
-	serverInstance.isAliveCache = isAliveResult
-	serverInstance.lastCheckedTime = time.Now()
-
-	return isAliveResult
-}
-
-func (serverInstance *ServerImplementation) ServeTheRequest(responseWriter http.ResponseWriter, httpRequest *http.Request) {
-	GlobalMutex.Lock()
-	GlobalCounter = GlobalCounter + 1
-	GlobalMutex.Unlock()
-
-	proxyObject := serverInstance.reverseProxyObject
-	proxyObject.ServeHTTP(responseWriter, httpRequest)
-}
-
-func (loadBalancer *LoadBalancerStruct) FindNextAvailableServerForRequest(isWebSocketRequest bool) ServerInterface {
-	loadBalancer.InternalMutex.Lock()
-	defer loadBalancer.InternalMutex.Unlock()
-
-	loopIterationCount := 0
-	totalServerCount := len(loadBalancer.serversList)
-
-	if isWebSocketRequest == true {
-		currentIndex := loadBalancer.RoundRobinCounterForWebSocketRequests % totalServerCount
-		selectedServer := loadBalancer.serversList[currentIndex]
-
-		for selectedServer.CheckIfServerIsCurrentlyAlive() == false {
-			loadBalancer.RoundRobinCounterForWebSocketRequests = loadBalancer.RoundRobinCounterForWebSocketRequests + 1
-			loopIterationCount = loopIterationCount + 1
-
-			newIndex := loadBalancer.RoundRobinCounterForWebSocketRequests % totalServerCount
-			selectedServer = loadBalancer.serversList[newIndex]
-
-			if loopIterationCount > totalServerCount {
-				noServerMessage := "No server is alive"
-				fmt.Print(noServerMessage + "\n")
-				loopIterationCount = 0
-			}
-		}
-
-		loadBalancer.RoundRobinCounterForWebSocketRequests = loadBalancer.RoundRobinCounterForWebSocketRequests + MagicNumber1
-		return selectedServer
-	} else if isWebSocketRequest == false {
-		currentIndex := loadBalancer.roundRobinCounterForHttpRequests % totalServerCount
-		selectedServer := loadBalancer.serversList[currentIndex]
-
-		continueLoop := true
-		for continueLoop {
-			if selectedServer.CheckIfServerIsCurrentlyAlive() {
-				continueLoop = false
-			} else {
-				loadBalancer.roundRobinCounterForHttpRequests = loadBalancer.roundRobinCounterForHttpRequests + 1
-				loopIterationCount = loopIterationCount + 1
-
-				newIndex := loadBalancer.roundRobinCounterForHttpRequests % totalServerCount
-				selectedServer = loadBalancer.serversList[newIndex]
-
-				if loopIterationCount > totalServerCount {
-					noServerMessage := "No server is alive"
-					fmt.Print(noServerMessage)
-					fmt.Print("\n")
-					loopIterationCount = MagicNumber2
-				}
-			}
-		}
-
-		loadBalancer.roundRobinCounterForHttpRequests = loadBalancer.roundRobinCounterForHttpRequests + 1
-		return selectedServer
-	}
-
-	// this should never be reached but adding for "safety"
-	return loadBalancer.serversList[0]
-}
-
-func (loadBalancer *LoadBalancerStruct) FindServerWithExistingDocumentConnection(documentIdentifier string) ServerInterface {
-	loadBalancer.SecondaryMutex.Lock()
-	defer loadBalancer.SecondaryMutex.Unlock()
-
-	documentIdCopy := documentIdentifier
-	documentIdCopy2 := strings.TrimSpace(documentIdCopy)
-	documentIdFinal := documentIdCopy2
-
-	existingConnection, connectionExists := loadBalancer.DocumentIdToWebSocketConnectionMapping[documentIdFinal]
-
-	if connectionExists == true {
-		if existingConnection != nil {
-			serverAddress, addressExists := loadBalancer.webSocketConnectionToServerAddressMap[existingConnection]
-
-			if addressExists == true {
-				if serverAddress != "" {
-					serverCount := len(loadBalancer.serversList)
-					for serverIndex := 0; serverIndex < serverCount; serverIndex++ {
-						currentServer := loadBalancer.serversList[serverIndex]
-						currentServerAddress := currentServer.GetAddress()
-
-						addressesMatch := currentServerAddress == serverAddress
-						if addressesMatch {
-							serverIsAlive := currentServer.CheckIfServerIsCurrentlyAlive()
-							if serverIsAlive == true {
-								return currentServer
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	// No existing connection found, create new one
-	newServer := loadBalancer.FindNextAvailableServerForRequest(true)
-
-	newWebSocketConnection := &websocket.Conn{}
-	loadBalancer.DocumentIdToWebSocketConnectionMapping[documentIdFinal] = newWebSocketConnection
-
-	newServerAddress := newServer.GetAddress()
-	loadBalancer.webSocketConnectionToServerAddressMap[newWebSocketConnection] = newServerAddress
-
-	return newServer
-}
-
-func (loadBalancer *LoadBalancerStruct) HandleProxyServing(responseWriter http.ResponseWriter, httpRequest *http.Request) {
-	queryParameters := httpRequest.URL.Query()
-	documentIdParameter := queryParameters.Get("document_id")
-
-	documentIdString := documentIdParameter
-	trimmedDocumentId := strings.TrimSpace(documentIdString)
-
-	documentIdLength := len(trimmedDocumentId)
-	hasDocumentId := documentIdLength > 0
-
-	if hasDocumentId == false {
-		targetServerForRequest := loadBalancer.FindNextAvailableServerForRequest(false)
-		targetServerForRequest.ServeTheRequest(responseWriter, httpRequest)
-	} else if hasDocumentId == true {
-		targetServerForRequest := loadBalancer.FindServerWithExistingDocumentConnection(trimmedDocumentId)
-		targetServerForRequest.ServeTheRequest(responseWriter, httpRequest)
-	}
-}
-
-func convertIntToString(intValue int) string {
-	return strconv.Itoa(intValue)
-}
\ No newline at end of file
diff --git a/repository_before/main.go b/repository_after/main.go
index d9db1ae1..e35df597 100644
--- a/repository_before/main.go
+++ b/repository_after/main.go
@@ -2,7 +2,7 @@ package main
 
 import (
 	"fmt"
-	"go-proxy/repository_before/app"
+	"go-proxy/repository_after/app"
 	"net/http"
 )
 
@@ -13,32 +13,22 @@ func main() {
 		"https://distributed-doc-3.onrender.com",
 	}
 
-	serverInterfaceList := make([]app.ServerInterface, 0)
-
-	for index := 0; index < len(serverAddressList); index++ {
-		currentAddress := serverAddressList[index]
-		newServer := app.CreateNewSimpleServerInstance(currentAddress, index)
-		serverInterfaceList = append(serverInterfaceList, newServer)
+	var interfaceList []app.ServerInterface
+	for i, addr := range serverAddressList {
+		interfaceList = append(interfaceList, app.CreateNewSimpleServerInstance(addr, i))
 	}
 
-	portNumberString := "7000"
-	loadBalancerInstance := app.CreateNewLoadBalancerInstance(portNumberString, serverInterfaceList)
-
-	requestHandlerFunction := func(responseWriter http.ResponseWriter, httpRequest *http.Request) {
-		loadBalancerInstance.HandleProxyServing(responseWriter, httpRequest)
-	}
+	lb := app.CreateNewLoadBalancerInstance("7000", interfaceList)
 
-	rootPath := "/"
-	http.HandleFunc(rootPath, requestHandlerFunction)
+	// Mux registration
+	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
+		lb.HandleProxyServing(w, r)
+	})
 
-	listenAddress := "0.0.0.0"
-	colonSeparator := ":"
-	portNumber := loadBalancerInstance.PortNumber
-	fullListenAddress := listenAddress + colonSeparator + portNumber
+	listenAddr := "0.0.0.0:" + lb.PortNumber
+	fmt.Printf("Starting Enterprise Load Balancer on %s\n", listenAddr)
 
-	fmt.Printf("Starting server on %s\n", fullListenAddress)
-	serverError := http.ListenAndServe(fullListenAddress, nil)
-	if serverError != nil {
-		app.HandleErrorFunction(serverError)
+	if err := http.ListenAndServe(listenAddr, nil); err != nil {
+		app.HandleErrorFunction(err)
 	}
 }
\ No newline at end of file
