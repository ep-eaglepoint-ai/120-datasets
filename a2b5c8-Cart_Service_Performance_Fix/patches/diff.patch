--- repository_before/cartService.js
+++ repository_after/cartService.js
@@ -4,18 +4,54 @@
 const HttpError = require("./utils/httpError");
 const logger = require("./config/logger");
 
+function decimalToNumber(value) {
+  if (value == null) return 0;
+  if (typeof value === "number") return value;
+  if (typeof value === "string") return Number(value);
+  if (typeof value.toString === "function") return Number(value.toString());
+  return Number(value);
+}
+
+function getPrimaryImageUrl(images) {
+  if (!Array.isArray(images) || images.length === 0) return undefined;
+  const primary = images.find((img) => img && img.isPrimary);
+  return (primary && primary.url) || images[0]?.url;
+}
+
+function normalizeAddOns(addOns) {
+  if (!Array.isArray(addOns) || addOns.length === 0) return [];
+  return addOns.map((addOn) => {
+    const addOnPrice = decimalToNumber(addOn.price);
+    return { name: addOn.name, _id: addOn._id, price: addOnPrice };
+  });
+}
+
+function recalculatePricing(cart) {
+  let subtotal = 0;
+  let totalItems = 0;
+
+  for (const item of cart.items) {
+    subtotal += decimalToNumber(item.subtotal);
+    totalItems += item.quantity;
+  }
+
+  cart.pricing.subtotal = subtotal;
+  cart.pricing.totalItems = totalItems;
+}
+
+function isDiscountActive(discount, now) {
+  if (!discount || !discount.isActive) return false;
+  const validFrom = discount.validFrom ? new Date(discount.validFrom) : null;
+  const validUntil = discount.validUntil ? new Date(discount.validUntil) : null;
+  return (!validFrom || now >= validFrom) && (!validUntil || now <= validUntil);
+}
+
 class CartService {
   async getCart(customerId) {
     try {
       const cart = await Cart.findOne({ customerId })
-        .populate({
-          path: 'items.menuItemId',
-          populate: {
-            path: 'merchantId',
-            model: 'Merchant',
-            select: 'businessName businessType isOpen rating _id'
-          }
-        });
+        .select("items pricing")
+        .lean();
 
       if (!cart) {
         return {
@@ -25,45 +61,65 @@
         };
       }
 
-      const items = cart.items.map(item => {
-        if (!item.menuItemId || !item.menuItemId.merchantId) {
-          return null;
-        }
-        return {
+      const menuItemIds = [];
+      for (const item of cart.items) {
+        if (item?.menuItemId) menuItemIds.push(item.menuItemId);
+      }
+
+      // Bulk fetch menu items and merchants (avoid populate N+1).
+      const menuItems = menuItemIds.length
+        ? await MenuItem.find({ _id: { $in: menuItemIds } })
+            .select("_id merchantId images")
+            .lean()
+        : [];
+
+      const menuItemById = new Map();
+      const merchantIds = [];
+      for (const mi of menuItems) {
+        menuItemById.set(String(mi._id), mi);
+        if (mi?.merchantId) merchantIds.push(mi.merchantId);
+      }
+
+      const merchants = merchantIds.length
+        ? await Merchant.find({ _id: { $in: merchantIds } })
+            .select("businessName businessType isOpen rating _id")
+            .lean()
+        : [];
+
+      const merchantById = new Map();
+      for (const m of merchants) merchantById.set(String(m._id), m);
+
+      const items = [];
+      for (const item of cart.items) {
+        const mi = item?.menuItemId ? menuItemById.get(String(item.menuItemId)) : null;
+        const merchant = mi?.merchantId ? merchantById.get(String(mi.merchantId)) : null;
+        if (!mi || !merchant) continue;
+
+        const price = decimalToNumber(item.price);
+        const subtotal = decimalToNumber(item.subtotal);
+        const addOns = normalizeAddOns(item.addOns);
+
+        items.push({
           _id: item._id,
-          menuItemId: item.menuItemId._id,
+          menuItemId: mi._id,
           name: item.name,
-          image: item.menuItemId.images?.find(img => img.isPrimary)?.url || item.menuItemId.images?.[0]?.url,
-          price: parseFloat(item.price.toString()),
+          image: getPrimaryImageUrl(mi.images),
+          price,
           quantity: item.quantity,
           variations: item.variations,
-          addOns: item.addOns.map(addOn => ({
-            name: addOn.name,
-            _id: addOn._id,
-            price: parseFloat(addOn.price.toString())
-          })),
-          subtotal: parseFloat(item.subtotal.toString()),
-          merchantInfo: item.menuItemId.merchantId,
-        };
-      }).filter(item => item !== null);
-
-      let subtotal = 0;
-      for (const item of cart.items) {
-        subtotal += parseFloat(item.subtotal.toString());
-      }
-      
-      let totalItems = 0;
-      for (const item of cart.items) {
-        totalItems += item.quantity;
+          addOns,
+          subtotal,
+          merchantInfo: merchant,
+        });
       }
 
       return {
         _id: cart._id,
         items,
         pricing: {
-          subtotal: parseFloat(cart.pricing.subtotal.toString()),
-          totalItems: cart.pricing.totalItems
-        }
+          subtotal: decimalToNumber(cart.pricing?.subtotal),
+          totalItems: cart.pricing?.totalItems || 0,
+        },
       };
     } catch (error) {
       logger.error(`Error getting cart: ${error.message}`);
@@ -79,7 +135,16 @@
         throw new HttpError("Quantity must be at least 1", 400);
       }
 
-      const menuItem = await MenuItem.findById(menuItemId);
+      // Independent fetches in parallel (cart is needed for write, menu item is read-only).
+      const [menuItem, existingCart] = await Promise.all([
+        MenuItem.findById(menuItemId)
+          .select(
+            "name merchantId price discountedPrice isAvailable productType images variants extras discount"
+          )
+          .lean(),
+        Cart.findOne({ customerId }),
+      ]);
+
       if (!menuItem) {
         throw new HttpError("Menu item not found", 404);
       }
@@ -87,74 +152,68 @@
         throw new HttpError("This menu item is currently unavailable", 400);
       }
 
-      let cart = await Cart.findOne({ customerId });
-
-      if (cart && cart.merchantId && cart.merchantId.toString() !== menuItem.merchantId.toString()) {
+      if (existingCart && existingCart.merchantId && !existingCart.merchantId.equals(menuItem.merchantId)) {
         throw new HttpError("Cannot add items from multiple merchants", 400);
       }
 
       let variantPrice = null;
-      if (menuItem.productType === 'variable') {
+      if (menuItem.productType === "variable") {
         if (!variations || variations.length === 0) {
           throw new HttpError("Product options must be selected for this item.", 400);
         }
-        const selectedVariant = menuItem.variants.find(variant =>
-          variations.length === variant.optionValues.length &&
-          variations.every(v =>
-            variant.optionValues.some(opt => opt.optionName === v.optionName && opt.value === v.value)
-          )
+        const selectedVariant = menuItem.variants.find(
+          (variant) =>
+            variations.length === variant.optionValues.length &&
+            variations.every((v) =>
+              variant.optionValues.some(
+                (opt) => opt.optionName === v.optionName && opt.value === v.value
+              )
+            )
         );
         if (!selectedVariant) {
           throw new HttpError("The selected product options are not a valid combination.", 400);
         }
-        variantPrice = parseFloat(selectedVariant.price.toString());
+        variantPrice = decimalToNumber(selectedVariant.price);
       }
 
-      let basePrice = variantPrice !== null ? variantPrice : parseFloat(menuItem.price.toString());
+      const now = new Date();
+      let basePrice = variantPrice !== null ? variantPrice : decimalToNumber(menuItem.price);
 
-      if (menuItem.discount && menuItem.discount.isActive) {
-        const validFrom = menuItem.discount.validFrom ? new Date(menuItem.discount.validFrom) : null;
-        const validUntil = menuItem.discount.validUntil ? new Date(menuItem.discount.validUntil) : null;
-        if ((!validFrom || new Date() >= validFrom) && (!validUntil || new Date() <= validUntil)) {
-          if (menuItem.discountedPrice) {
-            basePrice = parseFloat(menuItem.discountedPrice.toString());
-          }
-        }
+      if (isDiscountActive(menuItem.discount, now) && menuItem.discountedPrice != null) {
+        basePrice = decimalToNumber(menuItem.discountedPrice);
       }
 
-      const addOnsWithPrices = addOns.map(addOnFromClient => {
-        const addon = menuItem.extras.find(extra => extra.name === addOnFromClient.name);
-        if (!addon) return null;
-        return {
-          name: addon.name,
-          price: parseFloat(addon.price.toString()),
-          _id: addon._id
-        };
-      }).filter(Boolean);
+      const addOnsWithPrices = Array.isArray(addOns)
+        ? addOns
+            .map((addOnFromClient) => {
+              const addon = menuItem.extras.find((extra) => extra.name === addOnFromClient.name);
+              if (!addon) return null;
+              return { name: addon.name, price: decimalToNumber(addon.price), _id: addon._id };
+            })
+            .filter(Boolean)
+        : [];
 
-      let existingCart = await Cart.findOne({ customerId });
-      if (!existingCart) {
-        existingCart = new Cart({
+      const cart =
+        existingCart ||
+        new Cart({
           customerId,
           merchantId: menuItem.merchantId,
           items: [],
-          pricing: { subtotal: 0, totalItems: 0 }
+          pricing: { subtotal: 0, totalItems: 0 },
         });
-      }
-
-      const existingItem = existingCart.items.find(item => 
-        item.menuItemId.toString() === menuItem._id.toString()
-      );
 
+      const existingItem = cart.items.find((item) => item.menuItemId.equals(menuItem._id));
       if (existingItem) {
         throw new HttpError("This exact item configuration is already in your cart.", 409);
       }
 
-      const addOnsTotal = addOnsWithPrices.reduce((total, addon) => total + addon.price, 0);
+      let addOnsTotal = 0;
+      for (const addon of addOnsWithPrices) addOnsTotal += addon.price;
+
       const singleItemPrice = basePrice + addOnsTotal;
       const subtotal = singleItemPrice * quantity;
 
-      const newItem = {
+      cart.items.push({
         menuItemId: menuItem._id,
         name: menuItem.name,
         price: basePrice,
@@ -162,25 +221,10 @@
         variations,
         addOns: addOnsWithPrices,
         subtotal,
-      };
-
-      existingCart.items.push(newItem);
-      await existingCart.save();
-
-      const updatedCart = await Cart.findOne({ customerId });
-      let cartSubtotal = 0;
-      for (const item of updatedCart.items) {
-        cartSubtotal += parseFloat(item.subtotal.toString());
-      }
-      updatedCart.pricing.subtotal = cartSubtotal;
-
-      let cartTotalItems = 0;
-      for (const item of updatedCart.items) {
-        cartTotalItems += item.quantity;
-      }
-      updatedCart.pricing.totalItems = cartTotalItems;
+      });
 
-      await updatedCart.save();
+      recalculatePricing(cart);
+      await cart.save(); // single persistence operation
 
       return this.getCart(customerId);
     } catch (error) {
@@ -202,93 +246,67 @@
         throw new HttpError("Cart not found", 404);
       }
 
-      const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);
+      const itemIndex = cart.items.findIndex((item) => item._id.equals(itemId));
       if (itemIndex === -1) {
         throw new HttpError("Item not found in cart", 404);
       }
 
       const cartItem = cart.items[itemIndex];
-      const menuItem = await MenuItem.findById(cartItem.menuItemId);
+
+      const menuItem = await MenuItem.findById(cartItem.menuItemId)
+        .select("productType variants extras")
+        .lean();
 
       if (!menuItem) {
-        const cartToUpdate = await Cart.findOne({ customerId });
-        cartToUpdate.items.splice(itemIndex, 1);
-        await cartToUpdate.save();
-        
-        const cartForPricing = await Cart.findOne({ customerId });
-        let newSubtotal = 0;
-        for (const item of cartForPricing.items) {
-          newSubtotal += parseFloat(item.subtotal.toString());
-        }
-        cartForPricing.pricing.subtotal = newSubtotal;
-        
-        let newTotalItems = 0;
-        for (const item of cartForPricing.items) {
-          newTotalItems += item.quantity;
-        }
-        cartForPricing.pricing.totalItems = newTotalItems;
-        await cartForPricing.save();
-        
+        cart.items.splice(itemIndex, 1);
+        recalculatePricing(cart);
+        await cart.save(); // single persistence operation (even on this error path)
         throw new HttpError("The original menu item no longer exists.", 404);
       }
 
-      let basePrice = parseFloat(cartItem.price.toString());
+      let basePrice = decimalToNumber(cartItem.price);
 
-      if (Array.isArray(variations) && variations.length > 0 && menuItem.productType === 'variable') {
-        const selectedVariant = menuItem.variants.find(variant =>
-          variations.length === variant.optionValues.length &&
-          variations.every(v =>
-            variant.optionValues.some(opt => opt.optionName === v.optionName && opt.value === v.value)
-          )
+      if (Array.isArray(variations) && variations.length > 0 && menuItem.productType === "variable") {
+        const selectedVariant = menuItem.variants.find(
+          (variant) =>
+            variations.length === variant.optionValues.length &&
+            variations.every((v) =>
+              variant.optionValues.some(
+                (opt) => opt.optionName === v.optionName && opt.value === v.value
+              )
+            )
         );
         if (!selectedVariant) {
           throw new HttpError("The updated product options are not valid.", 400);
         }
-        basePrice = parseFloat(selectedVariant.price.toString());
+        basePrice = decimalToNumber(selectedVariant.price);
       }
 
-      const cartToModify = await Cart.findOne({ customerId });
-      cartToModify.items[itemIndex].price = basePrice;
-      if (variations) cartToModify.items[itemIndex].variations = variations;
-      await cartToModify.save();
+      cartItem.price = basePrice;
+      if (variations) cartItem.variations = variations;
 
       if (addOns !== undefined) {
-        const cartForAddons = await Cart.findOne({ customerId });
-        const addOnsWithPrices = addOns.map(addonFromClient => {
-          const addon = menuItem.extras.find(extra => extra._id.toString() === addonFromClient._id);
-          if (!addon) return null;
-          return {
-            name: addon.name,
-            price: parseFloat(addon.price.toString()),
-            _id: addon._id
-          };
-        }).filter(Boolean);
-        cartForAddons.items[itemIndex].addOns = addOnsWithPrices;
-        await cartForAddons.save();
-      }
-
-      const cartForQuantity = await Cart.findOne({ customerId });
-      const itemForQuantity = cartForQuantity.items[itemIndex];
-      const addOnsTotal = itemForQuantity.addOns.reduce((total, addon) => total + parseFloat(addon.price.toString()), 0);
-      const newSubtotal = (basePrice + addOnsTotal) * (quantity || itemForQuantity.quantity);
-
-      itemForQuantity.quantity = quantity || itemForQuantity.quantity;
-      itemForQuantity.subtotal = newSubtotal;
-      await cartForQuantity.save();
-
-      const cartForPricing = await Cart.findOne({ customerId });
-      let cartSubtotal = 0;
-      for (const item of cartForPricing.items) {
-        cartSubtotal += parseFloat(item.subtotal.toString());
-      }
-      cartForPricing.pricing.subtotal = cartSubtotal;
-      
-      let cartTotalItems = 0;
-      for (const item of cartForPricing.items) {
-        cartTotalItems += item.quantity;
-      }
-      cartForPricing.pricing.totalItems = cartTotalItems;
-      await cartForPricing.save();
+        const addOnsWithPrices = Array.isArray(addOns)
+          ? addOns
+              .map((addonFromClient) => {
+                const addon = menuItem.extras.find((extra) => extra._id.equals(addonFromClient._id));
+                if (!addon) return null;
+                return { name: addon.name, price: decimalToNumber(addon.price), _id: addon._id };
+              })
+              .filter(Boolean)
+          : [];
+        cartItem.addOns = addOnsWithPrices;
+      }
+
+      let addOnsTotal = 0;
+      for (const addon of cartItem.addOns) addOnsTotal += decimalToNumber(addon.price);
+
+      const effectiveQuantity = quantity || cartItem.quantity;
+      cartItem.quantity = effectiveQuantity;
+      cartItem.subtotal = (basePrice + addOnsTotal) * effectiveQuantity;
+
+      recalculatePricing(cart);
+      await cart.save(); // single persistence operation
 
       return this.getCart(customerId);
     } catch (error) {
@@ -304,22 +322,9 @@
         throw new HttpError("Cart not found", 404);
       }
 
-      cart.items = cart.items.filter((item) => item._id.toString() !== itemId);
-      await cart.save();
-
-      const cartForPricing = await Cart.findOne({ customerId });
-      let subtotal = 0;
-      for (const item of cartForPricing.items) {
-        subtotal += parseFloat(item.subtotal.toString());
-      }
-      cartForPricing.pricing.subtotal = subtotal;
-      
-      let totalItems = 0;
-      for (const item of cartForPricing.items) {
-        totalItems += item.quantity;
-      }
-      cartForPricing.pricing.totalItems = totalItems;
-      await cartForPricing.save();
+      cart.items = cart.items.filter((item) => !item._id.equals(itemId));
+      recalculatePricing(cart);
+      await cart.save(); // single persistence operation
 
       return this.getCart(customerId);
     } catch (error) {
@@ -336,12 +341,9 @@
       }
 
       cart.items = [];
-      await cart.save();
-
-      const cartForPricing = await Cart.findOne({ customerId });
-      cartForPricing.pricing.subtotal = 0;
-      cartForPricing.pricing.totalItems = 0;
-      await cartForPricing.save();
+      cart.pricing.subtotal = 0;
+      cart.pricing.totalItems = 0;
+      await cart.save(); // single persistence operation
 
       return this.getCart(customerId);
     } catch (error) {
